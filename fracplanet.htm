<html>

<head>
  <title>
    Fracplanet user manual
  </title>
  <meta name="keywords" content="Fracplanet, user documentation, user manual"/>
  <meta name="description" content="Fracplanet user documentation"/>
  <link rel="stylesheet" title="Default styles" type="text/css" href="fracplanet.css" media="screen,print"/>
</head>

<body>

<h1>
  Fracplanet user manual
</h1>

<h2>Introduction</h2>

<p>
  Fracplanet is an application to generate random planets and terrain with oceans, mountains, icecaps and rivers.
  Parameters are specified interactively and the results displayed using OpenGL.
  The generated objects can be dumped in Pov-Ray format.
</p>

<h2>Command line arguments</h2>

<p>
  Fracplanet has no command line arguments other than those intercepted and interpreted by Qt.
  These are pretty much what you'd expect most X11 applications to handle 
  e.g <code>-geometry <em>X</em>x<em>Y</em></code>.
</p>

<h2>GUI</h2>

<p>
  The fracplanet GUI is a tabbed control.
  The terrain generated is shown in a separate window (which disappears when regenerating).
  A progress dialog is generally displayed while generating terrain (except at startup).
</p>

<h3>Create tab</h3>

<p>
  Note that none of the parameters adjustable on this tab have any effect on the displayed model until one of 
  the &quot;Regenerate&quot; buttons is pressed.  This tab is further subdivided into sub-tabs
  (&quot;Terrain&quot;, &quot;Snow&quot;, &quot;Rivers&quot;, &quot;Colours&quot;, &quot;Clouds&quot;).
</p>

<h4>Terrain</h4>
  
<p>
  This tab is actually even further subdivided 
  (&quot;Basics&quot;, &quot;Subdivision&quot; and &quot;Noise&quot; tabs),
  but the list below doesn't distinguish.
</p>

<dl>
  <dt>Starting geometry: Generate...</dt>
  <dd>
    A pull-down menu (or &quot;combo-box&quot;) selects the initial geometry which will be &quot;fractalized&quot;.
    Planet creates planets by subdividing an icosahedron.
    The other terrain area type create planar terrain areas by subdividing one or more triangles.
    Note that the square type doesn't produce very good results because the triangles it uses aren't equilateral.
  </dd>
  <dt>Base land height</dt>
  <dd>
    This expresses the initial height of the terrain (relative to the sea level) as a percentage of the vertical maximum perturbation size.
    Negative values produce (on average) more ocean than land, positive values produce more land than ocean. 
  </dd>
  <dt>Terrain random seed</dt>
  <dd>
    Specifies the random number generator seed used when creating terrain.
    Regenerating without changing this value will produce the same terrain, allowing the user to play with subdivision levels, colours etc while still retaining the same basic pattern of oceans and continents. 
    The value is initially set to the system time on application start-up.
  </dd>
  <dt>Power law</dt>
  <dd>
    A power law applied to all above-sea-level heights after terrain generation.
    (This consists of normalising the height relative to the maximum height in the terrain model and raising it to the power of this number divided by 100).
    Values above 100 flatten low terrain, tending to produce smooth plains surrounding spiky mountains.
    Values below 100 flatten high terrain, tending to produce smooth highlands surrounded by steep cliffs.
  </dd>
  <dt>Subdivisions</dt>
  <dd>
    The number of subdivisions of the initial structure.
    Each successive level of subdivision increases the number of triangles by a factor of four, so users should increase this parameter with caution.
    This has a major impact on the amount of memory consumed, the frame rate and the responsiveness of the application.
  </dd>
  <dt>Unperturbed subdivisions</dt>
  <dd>
    Specifies the number of the subdivisions which will be performed <em>without</em> random perturbation of the vertices.
    Lower numbers (0, 1) produce a few large continents.
    Higher values produce many small islands.
  </dd>
  <dt>Vertical perturbation</dt>
  <dd>
    Specifies the maximum size of vertical perturbations at the first level of subdivision.
    The maximum perturbation size is then halved at each subsequent subdivision.
    Planets and terrain areas both have a nominal radius of 1.0, 
    and the number here is divided by 100 so if you specify a vertical variation of 12 you could get mountains which are on the order of 12 percent of the planet's radius high, or larger if subsequent perturbations accumulate upwards at a point (of course suppressing initial large perturbations using the &quot;Unperturbed&quot; parameter will tend to reduce this).
    This is of course a ridiculous height for mountains on anything but an asteroid, but using realistic values will just produce very boring looking planets. 
  </dd>
  <dt>Horizontal perturbation</dt>
  <dd>
    Specifies the maximum size of horizontal perturbations at the first level of subdivision.
    The maximum perturbation size is then halved at each subsequent subdivision.
    Beware of making this value too large as it can produce overhanging/self-intersecting terrain,
    on the other hand small values can be useful for breaking up obvious artifacts of the initial geometry.
  </dd>
  <dt>Noise terms</dt>
  <dd>
    Number of terms in a Perlin noise function added to the terrain heights.
    Each subsequent term doubles the frequency.
    The best way to get an appreciation of the qualitative differences between Perlin noise and
    subdivision-perturbation is to reduce &quot;Vertical perturbation&quot; (on the &quot;Subdivision&quot; tab)
    to zero and increase the number of noise terms.
  </dd>
  <dt>Noise frequency<dt>
  <dd>
    Frequency of 1st noise term.
    100 gives a scale on the order of the terrain radius.
    Subsequent terms double the frequency (and therefore halve their length scale).
  </dd>
  <dt>Noise amplitude<dt>
  <dd>
    Amplitude of 1st noise term, as a percentage of the nominal object radius.
  </dd>
  <dt>Noise amplitude decay rate<dt>
  <dd>
    The amplitude of subsequent noise terms decays to this percentage of the amplitude of the previous term.
    Fifty percent does the classic fractal thing of scaling perturbation size with length scale.
    Increasing it slightly (to e.g sixty percent) has the interesting effect of making rivers meander more
    as small-scale variations now have a bigger effect on local gradients than large scale features.
  </dd>
</dl>

<h4>Snow</h4>


<dl>
  <dt>Snowline at equator</dt>
  <dd>
    The nominal height of the snowline at the equator of a planet (and everywhere on a flat-based terrain area),
    expressed as a percentage of the maximum height of the terrain.
  </dd>
  <dt>Snowline at pole</dt>
  <dd>
    The nominal height of the snowline at the poles of a planet (unused for a flat-based terrain area),
    expressed as a percentage of the maximum height of the terrain.
  </dd>
  <dt>Snowline power law</dt>
  <dd>
    Tweaking this parameter lets you control whether the snowline remains high up and only plunges
    downward towards the poles, or whether it only quickly rises near the equator.
    Experiment, it has a fairly subtle effect.
  </dd>
  <dt>Snowline slope suppression</dt>
  <dd>
    The larger this value is, the harder it is for snow to stick to steep slopes 
    (you can see this effect for real on any mountain range).
    This breaks up the snowline quite nicely, as it otherwise tends to stop at 
    an artificially uniform height (reduce this parameter to zero to see what I mean).
  </dd>
  <dt>Snowline glacier effect</dt>
  <dd>
    If this parameter is positive, rivers tend to form glaciers and you 
    will see e.g white lines running out of snowy areas, and frozen lakes.
    If this parameter is negative rivers find it harder to freeze and 
    you will see them running through snowy areas and forming un-frozen lakes.
  </dd>
</dl>

<h4>Rivers</h4>

<dl>  
  <dt>Rivers</dt>
  <dd>
    Specifies the number of rivers to be generated.
    Note that rivers starting in the sea are immediately abandoned, but still count against this number
    (this is so the relative proportions of land/ocean can be tweaked without affecting the river source density).
    Rivers run from vertex to vertex along triangle edges, and are then rendered by blending from the
    river vertex colour to the surrounding terrain colour.
    This isn't ideal as they aren't very sharply defined.
    A previous version of the software flowed rivers from triangle to triangle
    which produced nice solid edged rivers (like the oceans are)
    but since they weren't flat it wasn't ideal either.
  </dd>
  <dt>Rivers seed</dt>
  <dd>
    Random number seed for river generation.
    If you change this, but not the perturbation seed, you can get a different river network on the same terrain.
  </dd>
  <dt>Lake becomes sea</dt>
  <dd>
    As a river is flowed across a terrain, it will sometimes form a lake as the water
    level rises sufficiently to overcome a terrain barrier.
    If the lake becomes sufficiently large (greater than the percentage of available surface area specified here) 
    then it is considered to have become an inland sea and it is no longer necessary for the lake to rise until 
    an outflow to be discovered (in the real world, surface evaporation replaces the outflow). 
    Increasing this number may result in larger lakes, but the process of river generation can 
    take considerably longer.
  </dd>
</dl>

<h4>Colours</h4>

<dl>
  <dt>Change colours</dt>
  <dd>
    Click on these buttons to bring up a colour-picking dialog and change the colour for the selected class of terrain.
    Each button displays the colour currently selected for that class.
    Obvious things you might want to do are to change the shoreline colour to 
    the same colour as the low level terrain (those beaches are pretty absurdly <em>wide</em> otherwise), 
    change the orange highlands to a more mountainous grey, or perhaps you preferd
    an apocalyptic &quot;lava world&quot; with red rivers and oceans (use emission to make them glow), 
    black shorelines and ash-grey terrain.
  </dd>
  <dt>Oceans and rivers emissive</dt>
  <dd>
    Sets the emission (also called &quot;glow&quot;) of lakes and rivers, on a scale of 0-100.
    This is mainly to facilitate glowing lava planets.
    Note that for terrain generated with emission non-zero, 
    an alternative OpenGL rendering path must be used which may be a little slower.
  </dd>
</dl>

<h4>Clouds</h4>

<p>
  The cloud layer, when generated, is a triangle mesh with variable
  translucency at each vertex.
  Note that it's <em>not</em> a texture in the normal sense.
</p>

<dl>
  <dt>Clouds enabled</dt>
  <dd>
    Select the check box to trigger creation of a cloud layer.
  </dd>
  <dt>Subdivisions</dt>
  <dd>
    When left unchecked, the cloud layer will be subdivided
    to the same degree as the terrain.
    Check the box for explicit control of cloud layer subdivision.
  </dd>
  <dt>Clouds seed.</dt>
  <dd>
    Change this to get a different cloud pattern.
  </dd>
  <dt>Cloud height</dt>
  <dd>
    Change this to get adjust the height of the clouds above the terrain.
  </dd>
</dl>

<h4>Other &quot;Create&quot; tab controls</h4>  
  
<dl>
  <dt>Regenerate</dt>
  <dd>
    Click this button to regenerate the planet/terrain area <em>without changing the random seeds</em>.
  </dd>
  <dt>Regenerate with new rivers seed</dt>
  <dd>
    Click this button to increment the river generation seed by one and regenerate.
    This gets you the same landscape with a different river network.
  </dd>
  <dt>Regenerate with new terrain seed</dt>
  <dd>
    Click this button increment the terrain seed by one and regenerate.
    This will get you a completely different terrain.
    (The river network will be different too, although it's seed won't have changed, as the rivers flow over the tarrain differently).
  </dd>
  <dt>Regenerate with new clouds seed</dt>
  <dd>
    Click this button increment the clouds seed by one and regenerate.
    This will get you a different cloud layer.
  </dd>
</dl>  

<h3>Save tab</h3>

<p>
  There are currently two supported save formats; POV-Ray and Blender.
  Strictly speaking it's Export which is provided, not save, as fracplanet's state cannot be restored (yet).
</p>

<h4>POV-Ray</h4>

<dl>
  <dt>Add atmosphere</dt>
  <dd>
    This tick-box causes additional POV-Ray directives to be emitted to render a thin layer of atmosphere.
  </dd>
  <dt>Sea object</dt>
  <dd>
    This tick-box causes a single sphere or infinite plane to generated for the oceans <em>instead</em> of numerous individual triangles.
  </dd>
  <dt>Base filename</dt>
  <dd>
    Enter the filename root to be used here.
    Two files will be generated, one with &quot;.pov&quot; appended, and one with &quot;.inc&quot; appended.
    The .inc file actually contains the object (using POV-Rays's <code>mesh2</code> format), plus any other objects generated due to the options above.
    The .pov just includes the .inc and adds a camera and light source and was primarily intended for testing:
    the expectation is that users will generally include the .inc into their own scenes, probably wrapping it
    in a POV-Ray <code>union</code> with embedded translate/scale/rotate directives).
  </dd>
  <dt>Save (POV-Ray)</dt>
  <dd>
    Click this button to create the POV-Ray files.
    This can take quite a long time so the progress bar is used to track the completed percentage.
  </dd>
</dl>

<p>
  There are additional comments on usage with POV-Ray <a href="#pov">below</a>.
</p>

<h4>Blender</h4>

<dl>
  <dt>Per vertex alpha</dt>
  <dd>
    This check box selects Fracplanet's preferred method for outputting clouds:
    by specifying per-vertex alpha components.
    However, Blender seems to ignore these so a workround is used and an opaque cloud layer is output
    (which should be ok if you fly underneath it and light it sensibly).
    You probably don't want to switch this on.
  </dd>
  <dt>Save (Blender)</dt>
  <dd>
    Click this button to create a file (a file dialog will appear) which can be imported into Blender.
    Note that the save file takes the form of a Python script (traditionally a <code>.py</code> file extension)
    which can be executed by Blender to reconstruct the fracplanet model.
  </dd>
</dl>

<p>
  There are additional comments on usage with Blender <a href="#blender">below</a>.
</p>

<h3>Render tab</h3>

<p>
  Options for OpenGL rendering appear on this tab.
  Generally none of these makes any difference to the underlying mesh or the saved meshes.
  (Exception: the &quot;low altitude&quot; colour is used when saving the cloud layer for Blender with the no-per-vertex-alpha workround.)
</p>

<p>
  Currently the options are a tickbox to select wireframe rendering,
  another to select display-list rendering (the default is immediate mode),
  another to select joystick mode for the mouse in flight mode
  (this simply affects whether pulling the mouse down the screen flies you in that
  direction, or whether it's more like an aircraft joystick and pitches you up instead),
  a slider controlling the amount of ambient light and two colour-picking buttons to select the
  viewing area's background colour at high and low altitude.
  The frame rate and current mesh size (number of triangles and vertices) is also displayed.
</p>

<p>
  Display list rendering is generally but not always faster
  (depends on your OpenGL implementation and graphics drivers).
  The main reason display list is not enabled by default is that
  the application may pause for a long time while OpenGL processes the
  list when it is first rendered; the amount of additional memory
  consumed by the display list is also a problem for very large meshes.  
</p>

<h3>About tab</h3>

<p>
  This tab displays information about the software (in particular the version number) and its license.
  There is a button to show a dialog containing user documentation.
</p>

<h3>Display window</h3>

<p>
  The display window, when shown, shows the current
  (most recently generated) terrain model.
  It is hidden when terrain is being regenerated or saved.
  The (badly named) &quot;tilt&quot; slider controls the latitude of the camera (when viewing a sphere-based object), 
  and the elevation (as in azimuth-elevation) of the camera when viewing a planar based terrain area.  
  Note that in the latter case the bottom half of the slider places the camera below base ground level/sea level, 
  which results in little being seen due to back-face culling.
  The &quot;spin rate&quot; controls the rate at which the object is rotated.
  The display window update rate is clamped to 75Hz, although this will typically
  only be reached at the lowest levels of subdivision.
</p>

<p>
  Hitting the &quot;Fly&quot; button puts you into free-flight mode.
  Pitch and yaw are controlled by the mouse position relative to the window centre
  (if the pitch control feels backwards, invert mouse-Y behaviour on the render tab).
  Roll is controlled by left/right mouse buttons, or the keyboard left/right arrow keys.
  Speed is controlled by the mouse wheel or the keyboard up/down arrow keys.
  Hit Esc to return to the normal viewing mode.
</p>

<a name="pov"><h2>Ray-tracing with POV-Ray</h2></a>

<p>
  To ray-trace a saved terrain (saved as terrain.pov and terrain.inc, say) do:<br/>
  <code>povray -Q9 -geometry 768x576 terrain.pov</code>
  Expect to get MANY "determinant too small" messages, 
  especially when using high degrees of subdivision.
  It used to take POVRay a LOT longer to read large models than
  to render them, but it seems to load much faster these days.
</p>

<p>
  Note that clouds, if generated, are output using POV-Ray's <code>double_illuminate</code>
  and <code>no_shadow</code> declarations.
  <code>double_illuminate</code> means that both sides of clouds are the same colour
  (rather than the underside being black).
  <code>no_shadow</code> means that the clouds cast no shadow on the ground
  (where the clouds are solid, the shadows are completely black, which looks more unnatural than no shadows).
  If desired, the declarations can be found at the end of the saved .inc file and simply edited out.
</p>

<p>
  (The author currently uses POV-Ray 3.5).
</p>

<a name="blender"><h2>Loading into Blender</h2></a>

<p>
  The easiest way to load mesh saved for blender is with blender's <code>-P &lt;filename.py&gt;</code>
  command line argument.
</p>

<p>
  Blender consumes an alarming amount of memory.
  Even loading a planet generated with fracplanet's default five levels of subdivision
  consumes a quarter of a gigabyte of RAM.
  It would probably help if fracplanet made some effort to optimise its meshes,
  and/or made use of textures rather than trying to do everything using geometry, but it doesn't yet.
</p>

<p>
  Blender's per-vertex-colours capability seems to ignore the alpha component of per-vertex colours,
  with the result that the cloud layer is rendered as a solid opaque colour.
  <em>If anyone has a solution to this it would be gratefully received.</em>
  Fracplanet's workround is to output an opaque surface with the blending
  (with the &quot;low altitude&quot; colour from the render tab controls) already done.
  The &quot;per-vertex alpha&quot; checkbox switches to the preferred behaviour in case it ever gets fixed.
</p>

<p>
  Each mesh is output with 2 materials.
  The clouds just use material 0.
  For the terrain, material 0 is for land facets, material 1 for the sea.
  This may be useful for users wanting to give them different shader properties.
</p>

<p>
  In Blender, the terrain mesh is named &quot;fracplanet.terrain&quot;.
  There will also be a &quot;fracplanet.cloud&quot; if clouds were enabled.
</p>

<p>
  Emissive terrain isn't supported.
</p>

<p>
  If you want to manipulate the terrain, and know a bit of Python,
  an easy way might be to edit the <code>.py</code> file;
  at the start there are two functions defined: 
  <code>v</code> called to create each vertex
  and <code>f</code> called to create each face.
</p>

<p>
  (The author currently uses Blender 2.36).
</p>

<h2>License</h2>

<p>
  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
</p>

<p>
  The full license can be also viewed on fracplanet's &quot;About&quot; tab.
</p>

</body>
